"use strict";(self.webpackChunkyield_docs=self.webpackChunkyield_docs||[]).push([[1687],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,k=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return n?o.createElement(k,s(s({ref:t},c),{},{components:n})):o.createElement(k,s({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var p=2;p<r;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},860:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return d}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),s=["components"],i={},l="Deployment",p={unversionedId:"operations/deployment",id:"operations/deployment",title:"Deployment",description:"Introduction",source:"@site/docs/operations/deployment.md",sourceDirName:"operations",slug:"/operations/deployment",permalink:"/yield-docs/operations/deployment",draft:!1,editUrl:"https://github.com/iamsahu/yield-docs/tree/master/docs/operations/deployment.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:'The "Yieldcurity" Standard',permalink:"/yield-docs/operations/code_reviews"},next:{title:"Emergency Plans",permalink:"/yield-docs/operations/emergency_plans"}},c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Mocks",id:"mocks",level:2},{value:"Assets and Oracle Sources",id:"assets-and-oracle-sources",level:3},{value:"Core",id:"core",level:2},{value:"Libraries",id:"libraries",level:3},{value:"Timelock",id:"timelock",level:3},{value:"Relay",id:"relay",level:3},{value:"Cloak",id:"cloak",level:3},{value:"Oracles",id:"oracles",level:3},{value:"Factories",id:"factories",level:3},{value:"Cauldron",id:"cauldron",level:3},{value:"Ladle",id:"ladle",level:3},{value:"Witch",id:"witch",level:3},{value:"Wand",id:"wand",level:3},{value:"Operations",id:"operations",level:2},{value:"Chi Sources",id:"chi-sources",level:3},{value:"Rate Sources",id:"rate-sources",level:3},{value:"Spot Sources",id:"spot-sources",level:3},{value:"CToken Sources",id:"ctoken-sources",level:3},{value:"Composite Pairs",id:"composite-pairs",level:3},{value:"Composite Paths",id:"composite-paths",level:3},{value:"Add Assets",id:"add-assets",level:3},{value:"Make Bases",id:"make-bases",level:3},{value:"Make Ilks",id:"make-ilks",level:3},{value:"Add Series",id:"add-series",level:3},{value:"Pools",id:"pools",level:2},{value:"Pool Initialization",id:"pool-initialization",level:3},{value:"Strategies",id:"strategies",level:2},{value:"Deployment",id:"deployment-1",level:3},{value:"Initialization",id:"initialization",level:3}],u={toc:d};function h(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"deployment"},"Deployment"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This guide is valid for the 11.6 deployment of Yield v2 (commit f5f0cb6)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'   "@yield-protocol/strategy-v2": "^0.11.0-rc3",\n   "@yield-protocol/utils-v2": "^2.4.6",\n   "@yield-protocol/vault-interfaces": "^2.3.0-rc6",\n   "@yield-protocol/vault-v2": "^0.11.0-rc7",\n   "@yield-protocol/yieldspace-interfaces": "^2.3.0-rc6",\n   "@yield-protocol/yieldspace-v2": "^0.11.0-rc4",\n')),(0,r.kt)("p",null,"The deployment steps are numbered sequentially."),(0,r.kt)("h2",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"For a protocol deployment, these are the parameters that need to be defined."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Governor"),(0,r.kt)("li",{parentName:"ul"},"Operations team"),(0,r.kt)("li",{parentName:"ul"},"Timelock delay"),(0,r.kt)("li",{parentName:"ul"},"Assets and assetIds"),(0,r.kt)("li",{parentName:"ul"},"Bases"),(0,r.kt)("li",{parentName:"ul"},"Ilks for each base, with collateralization ratio and limits for each pair"),(0,r.kt)("li",{parentName:"ul"},"For each Ilk: initial offer and duration for the witch"),(0,r.kt)("li",{parentName:"ul"},"Series, with seriesId, base, maturity, ilks, name and symbol"),(0,r.kt)("li",{parentName:"ul"},"Name and symbol for each pool"),(0,r.kt)("li",{parentName:"ul"},"Assets to initialize each pool"),(0,r.kt)("li",{parentName:"ul"},"Strategies to deploy, with name and symbol, starting pool and next pool")),(0,r.kt)("h2",{id:"mocks"},"Mocks"),(0,r.kt)("p",null,"Often, the operations will involve the addresses of external contracts. On testnet, we use mocks to substitute for external contracts. These won\u2019t be needed on mainnet."),(0,r.kt)("h3",{id:"assets-and-oracle-sources"},"Assets and Oracle Sources"),(0,r.kt)("p",null,"For testing purposes we use a series of mock assets and oracle sources. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan mocks/01_mocks.ts\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": assets.json, chiSources.json, rateSources.json, spotSources.json"),(0,r.kt)("h2",{id:"core"},"Core"),(0,r.kt)("p",null,"These steps are executed only once in the life of Yield v2. If they need to be executed again that is considered a ",(0,r.kt)("strong",{parentName:"p"},"major")," change subject to the maximum scrutiny."),(0,r.kt)("h3",{id:"libraries"},"Libraries"),(0,r.kt)("p",null,"There are three external libraries used in the Yield v2 protocol (SafeERC20Namer, YieldMath, and PoolExtensions). They are not orchestrated or permissioned, and store no data. They should never need to be redeployed. This script also deploys PoolExtensionsWrapper.sol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/10_libraries.ts\n")),(0,r.kt)("h3",{id:"timelock"},"Timelock"),(0,r.kt)("p",null,"During operations the Timelock will allow users to know in advance of any changes to the protocol. During deployment it will allow us to bundle transactions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/11_timelock.ts\n")),(0,r.kt)("p",null,"The Timelock is deployed with no delay and with all the roles granted to the deployer. This initial configuration makes it work as a transaction relayer. Before the protocol is live, the roles and delay will be adjusted so that the Timelock assumes its intended function."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": governance.json"),(0,r.kt)("h3",{id:"relay"},"Relay"),(0,r.kt)("p",null,"To ease operations in testnets, a Relay is deployed that has governance permissions over Timelock. Owning the Relay means being able to propose, approve and execute Timelock proposals in a single transaction. Do not use on mainnet."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan mocks/02_relay.ts\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": governance.json"),(0,r.kt)("h3",{id:"cloak"},"Cloak"),(0,r.kt)("p",null,"The Cloak stores the orchestration permissions between contracts, in a way that it will be safe to isolate contracts from the rest of the protocol in an emergency."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/12_cloak.ts\n")),(0,r.kt)("p",null,"All contracts that inherit from AccessControl must give ROOT access to the Cloak, so that the latter can edit the access control permissions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": governance.json"),(0,r.kt)("h3",{id:"oracles"},"Oracles"),(0,r.kt)("p",null,"To reduce the number of IOracle contracts deployed we use MultiOracles that allow to access several data sources of the same type for a single contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/13_oracles.ts\n")),(0,r.kt)("p",null,"The oracles deployed are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   chainlinkOracle: ChainlinkMultiOracle,\n   compoundOracle: CompoundMultiOracle,\n   compositeOracle: CompositeMultiOracle,\n   cTokenOracle: CTokenMultiOracle,\n   uniswapOracle: UniswapV3Oracle,\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on these contracts, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in these contracts."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h3",{id:"factories"},"Factories"),(0,r.kt)("p",null,"We use the Wand to ensure that adding assets and series to the protocol is a robust process. To allow the Wand to deploy Join, FYToken and Pool contracts, and stay within the Spurious Dragon 24Kb contract size limit, we use factories."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/13_factories.ts\n")),(0,r.kt)("p",null,"The factories deployed are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   poolFactory: PoolFactory,\n   joinFactory: JoinFactory,\n   fyTokenFactory: FYTokenFactory,\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on these contracts, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in these contracts."),(0,r.kt)("p",null,"To deploy the factories, the libraries need to have been deployed first."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h3",{id:"cauldron"},"Cauldron"),(0,r.kt)("p",null,"The Cauldron is the accounting contract for the Yield v2 Protocol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/14_cauldron.ts\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on the Cauldron, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in the Cauldron."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h3",{id:"ladle"},"Ladle"),(0,r.kt)("p",null,"The Ladle is the routing contract for the Yield v2 Protocol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/15_ladle.ts\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on the Ladle, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in the Ladle."),(0,r.kt)("p",null,"The Ladle gets permission to use several permissioned functions in the Cauldron. A plan is stored in the Cloak to pause or remove those permissions in an emergency."),(0,r.kt)("p",null,"To deploy the Ladle, the Cauldron needs to have been deployed first."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h3",{id:"witch"},"Witch"),(0,r.kt)("p",null,"The Witch is the liquidations contract for the Yield v2 Protocol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/16_Witch.ts\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on the Witch, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in the Witch."),(0,r.kt)("p",null,"The Witch gets permission to use several permissioned functions in the Cauldron. A plan is stored in the Cloak to pause or remove those permissions in an emergency."),(0,r.kt)("p",null,"To deploy the Witch, the Ladle (and therefore Cauldron) needs to have been deployed first."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h3",{id:"wand"},"Wand"),(0,r.kt)("p",null,"The Wand is a helper contract to add assets and series to the Yield v2 Protocol. While its use is not strictly necessary, it is recommended to avoid mistakes on these operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan core/17_Wand.ts\n")),(0,r.kt)("p",null,"The Timelock and the Cloak get ROOT permission on the Wand, while the deployer gets his permissions removed. The Timelock gets access to all the governance functions in the Wand."),(0,r.kt)("p",null,"The Wand gets permission to use several permissioned functions in the Cauldron, Ladle, Witch and Factories. A plan is stored in the Cloak to pause or remove those permissions in an emergency."),(0,r.kt)("p",null,"To deploy the Wand, the Cauldron, Ladle, Witch and Factories need to have been deployed first."),(0,r.kt)("p",null,"To execute the ",(0,r.kt)("inlineCode",{parentName:"p"},"makeBase")," function, appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"chi")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rate")," data sources need to have been set in an oracle."),(0,r.kt)("p",null,"To execute the ",(0,r.kt)("inlineCode",{parentName:"p"},"makeIlk")," function, appropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"spot")," data sources need to have been set in an oracle, and the collateral must have been enabled for liquidations in the Witch with ",(0,r.kt)("inlineCode",{parentName:"p"},"setIlk"),"."),(0,r.kt)("p",null,"To execute the ",(0,r.kt)("inlineCode",{parentName:"p"},"addSeries")," function, ",(0,r.kt)("inlineCode",{parentName:"p"},"makeBase")," needs to have been executed first for the chosen underlying."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": protocol.json"),(0,r.kt)("h2",{id:"operations"},"Operations"),(0,r.kt)("p",null,"The operations are expected to be repeatedly executed during the lifetime of Yield v2. "),(0,r.kt)("h3",{id:"chi-sources"},"Chi Sources"),(0,r.kt)("p",null,"The Chi Sources produce data for fyToken redemption, and need to be present before an asset can be made into a base. Currently we only support Compound cTokens as a source of Chi."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/20_updateChiSource.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers and addresses of the cTokens to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' const newSources: Array<[string, string]> = [\n   [DAI,  "0xD9D6D61bc216a0BE1EecA4155b258CbB3030d23f"],\n   [USDC, "0x078FfF3582342a16a7b038E6F4Fc9E88F738143d"],\n   [USDT, "0x1292BAe0Ba398F9e480251b8C40D2A171EC446D1"],\n   // [stringToBytes6(\'TST3\'), "0x8A93d247134d91e0de6f96547cB0204e5BE8e5D8"],\n ]\n')),(0,r.kt)("p",null,"The sources are set in the compoundOracle from protocol.json, as an assetId/CHI pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: compoundOracle.address,\n  data: compoundOracle.interface.encodeFunctionData("setSource", [baseId, CHI, sourceAddress])\n})\n')),(0,r.kt)("p",null,"The script reads the current chiSources.json to update it with the new sources. If there are no current sources an empty json Map must be provided in chiSources.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, chiSources.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": chiSources.json"),(0,r.kt)("h3",{id:"rate-sources"},"Rate Sources"),(0,r.kt)("p",null,"The Rate Sources produce data for debt accrual after maturity, and need to be present before an asset can be made into a base. Currently we only support Compound cTokens as a source of Rate."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/21_updateRateSource.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers and addresses of the cTokens to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' const newSources: Array<[string, string]> = [\n   [DAI,  "0x78F3579FbBb4a9894cE27cC201216Ef46A132f1c"],\n   [USDC, "0x625E23f0C081CF8a2bbb87738087D8b0A5f5F412"],\n   [USDT, "0xBce93F0D091092D780C6A386fb6d34780FFb031C"],\n   // [stringToBytes6(\'TST3\'), "0x8A93d247134d91e0de6f96547cB0204e5BE8e5D8"],\n ]\n')),(0,r.kt)("p",null,"The sources are set in the compoundOracle from protocol.json, as an assetId/RATE pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: compoundOracle.address,\n  data: compoundOracle.interface.encodeFunctionData("setSource", [\n    baseId,\n    RATE,\n    sourceAddress\n  ])\n})\n')),(0,r.kt)("p",null,"The script reads the current rateSources.json to update it with the new sources. If there are no current sources an empty json Map must be provided in rateSources.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, rateSources.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": rateSources.json"),(0,r.kt)("h3",{id:"spot-sources"},"Spot Sources"),(0,r.kt)("p",null,"The Spot Sources produce data for vault collateralization checks, and need to be present before an asset can be made into a ilk. Currently we support Chainlink aggregators as a source of Spot."),(0,r.kt)("p",null,"When setting up a source, the reverse is also set. The ChainlinkMultiOracle will also always return the input amount as the output amount when a base is the same as the quote."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/22_updateSpotSource.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of base and quote, the string identifier for the appropriate MultiOracle in protocol.json, and addresses of the aggregators to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newSources: Array<[string, string, string, string]> = [\n   [DAI, ETH,   'chainlinkOracle', \"0x22B58f1EbEDfCA50feF632bD73368b2FdA96D541\"],\n   [USDC, ETH,  'chainlinkOracle', \"0x64EaC61A2DFda2c3Fa04eED49AA33D021AeC8838\"],\n   [USDT, ETH,  'chainlinkOracle', \"0x0bF499444525a23E7Bb61997539725cA2e928138\"],\n   [WBTC, ETH,  'chainlinkOracle', \"0xF7904a295A029a3aBDFFB6F12755974a958C7C25\"]\n ]\n")),(0,r.kt)("p",null,"The sources are set in the specified IOracle from protocol.json, as an baseId/quoteId pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: oracle.address,\n  data: oracle.interface.encodeFunctionData("setSource", [\n    baseId,\n    quoteId,\n    sourceAddress\n  ])\n})\n')),(0,r.kt)("p",null,"The script reads the current spotSources.json to update it with the new sources. If there are no current sources an empty json Map must be provided in spotSources.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, spotSources.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": spotSources.json"),(0,r.kt)("h3",{id:"ctoken-sources"},"CToken Sources"),(0,r.kt)("p",null,"The cToken Sources produce spot data to use cToken as collateral, and need to be present before an cToken can be made into an ilk."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/23_updateCTokenSource.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of the cToken and its underlying, the string identifier for the CTokenMultiOracle, and addresses of the cTokens to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newSources: Array<[string, string, string, string]> = [\n   [CDAI, DAI, 'cTokenOracle',   \"0xf0d0eb522cfa50b716b3b1604c4f0fa6f04376ad\"],\n   [CUSDC, USDC, 'cTokenOracle', \"0x4a92e71227d294f041bd82dd8f78591b75140d63\"],\n   [CUSDT, USDT, 'cTokenOracle', \"0x3f0a0ea2f86bae6362cf9799b523ba06647da018\"]\n ]\n")),(0,r.kt)("p",null,"The sources are set in the compoundOracle from protocol.json, as an assetId/CHI pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: cTokenOracle.address,\n  data: cTokenOracle.interface.encodeFunctionData("setSource", [baseId, quoteId, sourceAddress])\n})\n')),(0,r.kt)("p",null,"The script reads the current cTokenSources.json to update it with the new sources. If there are no current sources an empty json Map must be provided in cTokenSources.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, cTokenSources.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": cTokenSources.json"),(0,r.kt)("h3",{id:"composite-pairs"},"Composite Pairs"),(0,r.kt)("p",null,"When there isn\u2019t an available source of Spot for a given token pair, we will combine several IOracle Spot feeds using a CompositeMultiOracle. First we must configure the CompositeMultiOracle with the available Spot sources. There is no current use for the CompositeMultiOracle."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/24_updateCompositePairs.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of base and quote, and the string identifier for the appropriate IOracle in protocol.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newCompositePairs: Array<[string, string, string]> = [\n   /*[DAI, ETH, 'chainlinkOracle'],\n   [USDC, ETH, 'chainlinkOracle'],\n   [USDT, ETH, 'chainlinkOracle'],\n   [WBTC, ETH, 'chainlinkOracle'],*/\n ]\n")),(0,r.kt)("p",null,"The sources are set in the specified IOracle from protocol.json, as an baseId/quoteId pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: compositeOracle.address,\n  data: compositeOracle.interface.encodeFunctionData("setSource", [\n    baseId,\n    quoteId, \n    protocol.get(oracleName) as string\n  ])\n})\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("h3",{id:"composite-paths"},"Composite Paths"),(0,r.kt)("p",null,"When there isn\u2019t an available source of Spot for a given token pair, we will combine several IOracle Spot feeds using a CompositeMultiOracle. Now we must configure the CompositeMultiOracle with the appropriate paths between the Pairs that were added in the previous step. There is no current use for the CompositeMultiOracle."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/25_updateCompositePaths.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of base and quote, and an array with the bytes6 identifiers of the intermediate steps. For example ",(0,r.kt)("inlineCode",{parentName:"p"},"[DAI, USDC, [ETH]]")," means that to calculate the DAI/USDC price we will combine the DAI/ETH and the ETH/USDC prices."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newCompositePaths: Array<[string, string, Array<string>]> = [\n   /* [DAI, USDC, [ETH]],\n   [DAI, USDT, [ETH]],\n   [DAI, WBTC, [ETH]],\n   [USDC, DAI, [ETH]],\n   [USDC, USDT, [ETH]],\n   [USDC, WBTC, [ETH]],\n   [USDT, DAI, [ETH]],\n   [USDT, USDC, [ETH]],\n   [USDT, WBTC, [ETH]] */\n ]\n")),(0,r.kt)("p",null,"The paths are set in the specified CompositeMultiOracle from protocol.json, enabling a baseId/quoteId pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push({\n  target: compositeOracle.address,\n  data: compositeOracle.interface.encodeFunctionData("setPath", [\n    baseId,\n    quoteId,\n    path\n  ])\n})\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("h3",{id:"add-assets"},"Add Assets"),(0,r.kt)("p",null,"Adding assets makes them known to the Yield v2 core contracts using the Wand, and deploys a Join for them, but doesn\u2019t set them up as collateral or underlying yet. This is a prerequisite to any other steps involving assets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/30_addAsset.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers and addresses of the assets to use."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' const newAssets: Array<[string, string]> = [\n   [DAI,  "0xaFCdc724EB8781Ee721863db1B15939675996484"],\n   [USDC, "0xeaCB3AAB4CA68F1e6f38D56bC5FCc499B76B4e2D"],\n   [ETH,  "0x55C0458edF1D8E07DF9FB44B8960AecC515B4492"],\n   [TST,  "0x51C9B30BE0417559A467D1f65d710a73E5845B3a"],\n   [WBTC, "0xD5FafCE68897bdb55fA11Dd77858Df7a9a458D92"],\n   [USDT, "0x233551369dc535f5fF3517c28fDCce81d650063e"],\n   [CDAI,  "0xf0d0eb522cfa50b716b3b1604c4f0fa6f04376ad"],\n   [CUSDC, "0x4a92e71227d294f041bd82dd8f78591b75140d63"],\n   [CUSDT, "0x3f0a0ea2f86bae6362cf9799b523ba06647da018"],\n   // [stringToBytes6(\'TST3\'), "0xfaAddC93baf78e89DCf37bA67943E1bE8F37Bb8c"],\n ]\n')),(0,r.kt)("p",null,"The script reads the current joins.json to update it with the new contracts. If there are no current Join contracts an empty json Map must be provided in joins.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,"As part of the Join deployment process, the Wand obtains ROOT permissions on the Join, and gives the same role to the deployer (in this case, the Timelock). It also gives ",(0,r.kt)("inlineCode",{parentName:"p"},"JOIN")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"EXIT")," permissions to the Ladle."),(0,r.kt)("p",null,"The Timelock obtains permission to use the governance functions in the deployed Joins. A plan is stored in the Cloak to isolate the new Join from the Ladle in an emergency."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, assets.json, joins.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": joins.json"),(0,r.kt)("h3",{id:"make-bases"},"Make Bases"),(0,r.kt)("p",null,"Making an asset into a base allows using it as an underlying for series and pools in Yield v2. This is done using the Wand, and is a prerequisite to use the asset as a base in a series."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/31_makeBase.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of the assets to make into bases, as well as the string identifier in protocol.json of the IOracle with the assetId/RATE pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newBases: Array<[string, string]> = [\n   [DAI,  'compoundOracle'],\n   [USDC, 'compoundOracle'],\n   [USDT, 'compoundOracle'],\n   // [stringToBytes6('TST3'), 'compoundOracle'],\n ]\n")),(0,r.kt)("p",null,"The script verifies that the Chi and Rate sources for the assets supplied are present in the IOracle specified."),(0,r.kt)("p",null,"As part of this process, the Wand gives ",(0,r.kt)("inlineCode",{parentName:"p"},"JOIN")," permissions to the Witch. A plan is stored in the Cloak to remove this permission in an emergency."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("h3",{id:"make-ilks"},"Make Ilks"),(0,r.kt)("p",null,"Making an asset into an ilk for a given base allows using it as an collateral for vaults of corresponding series in Yield v2. This is done using the Wand."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/32_makeIlk.ts\n")),(0,r.kt)("p",null,"The script includes inside:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An existing base (bytes6 identifier)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The asset to make into an ilk for the base (bytes6 identifier)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The string identifier in protocol.json of the IOracle with the baseId/ilkId pair. This can currently be the chainlinkOracle or the compositeOracle.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The collateralization ratio, with 6 decimal places. 1500000 = 150%.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The reverse of the collateralization ratio, with 6 decimal places. 666666 = 66%.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The debt ceiling for the base/ilk pair, with some zeros added afterwards.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The dust level for the base/ilk pair, with some zeros added afterwards.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The number of zeros to add to the debt ceiling and dust level. Note this needs to be the decimals of the base in the base/ilk pair.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," // Input data: baseId, ilkId, oracle, ratio (1000000 == 100%), inv(ratio), line, dust, dec\n const newIlks: Array<[string, string, string, number, number, number, number, number]> = [\n   [DAI, ETH, CHAINLINK, 1400000, 714000, 100000, 1, 18],\n   [DAI, DAI, CHAINLINK, 1000000, 1000000, 10000000, 0, 18], // Constant 1, no dust\n   [DAI, USDC, CHAINLINK, 1330000, 751000, 100000, 1, 18], // Via ETH\n   [DAI, WBTC, CHAINLINK, 1500000, 666000, 100000, 1, 18], // Via ETH\n//    [DAI, USDT, CHAINLINK, 1000000, 100000, 1, 18], // Via ETH\n   [USDC, ETH, CHAINLINK, 1400000, 714000, 100000, 1, 6],\n   [USDC, DAI, CHAINLINK, 1330000, 751000, 100000, 1, 6], // Via ETH\n   [USDC, USDC, CHAINLINK, 1000000, 1000000, 10000000, 0, 6], // Constant 1, no dust\n   [USDC, WBTC, CHAINLINK, 1500000, 666000, 100000, 1, 6], // Via ETH\n//    [USDC, USDT, CHAINLINK, 1000000, 100000, 1, 6], // Via ETH\n/*    [USDT, USDT, CHAINLINK, 1000000, 100000, 0, 18], // Constant 1, no dust\n   [USDT, DAI, CHAINLINK, 1000000, 100000, 1, 18], // Via ETH\n   [USDT, USDC, CHAINLINK, 1000000, 100000, 1, 18], // Via ETH\n   [USDT, ETH, CHAINLINK, 1000000, 100000, 1, 18],\n   [USDT, WBTC, CHAINLINK, 1000000, 100000, 1, 18], // Via ETH */\n//    [DAI, CDAI, CTOKEN, 1000000, 1000000, 1, 18],\n//    [USDC, CUSDC, CTOKEN, 1000000, 1000000, 1, 6],\n//    [USDT, CUSDT, CTOKEN, 1000000, 1000000, 1, 18],\n ]\n")),(0,r.kt)("p",null,"The script verifies that the Spot sources for the pairs supplied are present in the IOracle specified."),(0,r.kt)("p",null,"The ilk is enabled in the Witch for liquidations, with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"line"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"dust")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dec")," parameters as in the Cauldron."),(0,r.kt)("p",null,"As part of this process, the Wand gives ",(0,r.kt)("inlineCode",{parentName:"p"},"EXIT")," permissions to the Witch.  A plan is stored in the Cloak to remove this permission in an emergency. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("h3",{id:"add-series"},"Add Series"),(0,r.kt)("p",null,"Adding a series is a complex process that deploys a fyToken and a Pool contracts. This is done using the Wand."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/33_addSeries.ts\n")),(0,r.kt)("p",null,"The script includes inside the bytes6 identifiers of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A bytes6 identifier for the series, which gets LP added for the pool symbol.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The bytes6 identifier of the asset to use as an underlying.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The maturity of the series, in unix time.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An array of assets to be used as ilks for the series.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The name for the fyToken, which gets added \u201cLP Token\u201d for the corresponding pool.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The symbol for the fyToken, which gets added \u201cLP\u201d for the corresponding pool.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," const newSeries: Array<[string, string, number, string[], string, string]> = [\n   [stringToBytes6('0104'), DAI,  EODEC21, [ETH, DAI, USDC, WBTC], 'FYDAI2112', 'FYDAI2112'], // Dec21\n   [stringToBytes6('0105'), DAI,  EOMAR22, [ETH, DAI, USDC, WBTC], 'FYDAI2203', 'FYDAI2203'], // Mar22\n   [stringToBytes6('0204'), USDC, EODEC21, [ETH, DAI, USDC, WBTC], 'FYUSDC2112', 'FYUSDC2112'],\n   [stringToBytes6('0205'), USDC, EOMAR22, [ETH, DAI, USDC, WBTC], 'FYUSDC2203', 'FYUSDC2203'],\n ]\n")),(0,r.kt)("p",null,"The asset supplied as base needs to have been made into a base, and the ilks supplied need to have been made into ilks for the base supplied."),(0,r.kt)("p",null,"The deployment of a series costs about 10M gas, so only one can be done per block. The script uses the Timelock for deployment, but does one proposal per series instead of bundling them as for the rest of the protocol."),(0,r.kt)("p",null,"As part of the Join deployment process, the Timelock obtains ROOT permissions on the fyToken. The fyToken contract is also permissioned to ",(0,r.kt)("inlineCode",{parentName:"p"},"EXIT")," from the Join for its underlying, so that it can be redeemed. The Ladle is permissioned to ",(0,r.kt)("inlineCode",{parentName:"p"},"MINT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BURN")," fyToken.  A plan is stored in the Cloak to remove these permissions in an emergency."),(0,r.kt)("p",null,"The script reads the current fyTokens.json and pools.json to update it with the new contracts. If there are no current FYToken or Pool contracts an empty json Map must be provided in fyTokens.json and pools.json."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{"dataType":"Map","value":[]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, fyTokens.json (for updating), pools.json (for updating)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": fyTokens.json, pools.json"),(0,r.kt)("h2",{id:"pools"},"Pools"),(0,r.kt)("h3",{id:"pool-initialization"},"Pool Initialization"),(0,r.kt)("p",null,"The initialization of pools can be done by bundling a transaction to transfer underlying to the pool, with a transaction to mint LP tokens. All pools are intialized by having the Timelock transfer an equivalent of $100 to the pool, with the LP tokens sent to the zero address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/34_initPools.ts\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, pools.json"),(0,r.kt)("h2",{id:"strategies"},"Strategies"),(0,r.kt)("h3",{id:"deployment-1"},"Deployment"),(0,r.kt)("p",null,"The deployment of liquidity strategies is done with a script, in the same manner as the core protocols were deployed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan strategies/40_strategies.ts\n")),(0,r.kt)("p",null,"The script includes inside the init data: It includes the name and symbol for the strategy, as well as the bytes6 identifier for the base asset that will be common to all pools that the strategy works with."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"export const strategiesData: Array<[string, string, string]> = [ // name, symbol, baseId\n     ['YSDAIQ1', 'YSDAIQ1', DAI],\n     ['YSDAIQ2', 'YSDAIQ2', DAI],\n     ['YSUSDCQ1', 'YSUSDCQ1', USDC],\n     ['YSUSDCQ2', 'YSUSDCQ2', USDC],\n]\n")),(0,r.kt)("p",null,"As part of the deployment process, the Timelock is given ROOT permissions to each Strategy, as well as permission to execute all governance actions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Output"),": strategies.json"),(0,r.kt)("h3",{id:"initialization"},"Initialization"),(0,r.kt)("p",null,"The initialization of strategies involves at least four steps, and is provided to be used in testnets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run --network kovan operations/41_initStrategies.ts\n")),(0,r.kt)("p",null,"The input data includes a string to be used as both name and symbol for the strategy, as well as the bytes6 identifiers for the first series/pool pair, and the next series pool pair. The bytes6 identifiers for a series and the corresponding pool usually match."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"const strategiesInit: Array<[string, [string, string], [string, string]]> = [\n  // [strategyId, [startPoolId, startSeriesId],[nextPoolId,nextSeriesId]]\n  ['YSDAIQ1',\n    [stringToBytes6('0105'), stringToBytes6('0105')],\n    [stringToBytes6('0107'), stringToBytes6('0107')]\n  ],\n  ['YSDAIQ2',\n    [stringToBytes6('0104'), stringToBytes6('0104')],\n    [stringToBytes6('0106'), stringToBytes6('0106')]\n  ],\n  ['YSUSDCQ1',\n    [stringToBytes6('0205'), stringToBytes6('0205')],\n    [stringToBytes6('0207'), stringToBytes6('0207')]\n  ],\n  ['YSUSDCQ2',\n    [stringToBytes6('0204'), stringToBytes6('0204')],\n    [stringToBytes6('0206'), stringToBytes6('0206')]\n  ],\n]\n")),(0,r.kt)("p",null,"The strategy needs to be supplied with underlying to mint the initial Strategy tokens. We mint the underlying in testnets, but in mainnet it would be done with a transfer from the Timelock."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push(\n  {\n    target: base.address,\n    data: base.interface.encodeFunctionData("mint", [\n      strategy.address,\n      baseUnit.mul(1000)\n    ])\n  },\n)\n')),(0,r.kt)("p",null,"As part of the initialization process, the Strategy is added as an Integration to the Ladle, to allow the Ladle to route calls to the Strategy."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push(\n  {\n    target: ladle.address,\n    data: ladle.interface.encodeFunctionData("addIntegration", [\n      strategy.address,\n      true\n    ])\n  },\n)\n')),(0,r.kt)("p",null,"As part of the initialization process, the Strategy is added as a Token to the Ladle, to allow the Ladle to transfer and permit Strategy tokens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'proposal.push(\n  {\n    target: ladle.address,\n    data: ladle.interface.encodeFunctionData("addToken", [\n      strategy.address,\n      true\n    ])\n  },\n)\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Input"),": governance.json, protocol.json, pools.json, strategies.json"))}h.isMDXComponent=!0}}]);