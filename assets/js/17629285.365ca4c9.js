"use strict";(self.webpackChunkyield_docs=self.webpackChunkyield_docs||[]).push([[3877],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=o.createContext({}),c=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(i,".").concat(m)]||u[m]||p[m]||a;return n?o.createElement(h,l(l({ref:t},d),{},{components:n})):o.createElement(h,l({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var c=2;c<a;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1819:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return i},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var o=n(7462),r=n(3366),a=(n(7294),n(3905)),l=["components"],s={},i="Emergencies",c={unversionedId:"developers/emergencies",id:"developers/emergencies",title:"Emergencies",description:"In Yield v2 there are two types of emergency procedures to effect change in the smart contracts as a response to an emergency: Emergency Plans, and Emergency Proposals.",source:"@site/docs/developers/emergencies.md",sourceDirName:"developers",slug:"/developers/emergencies",permalink:"/yield-docs/developers/emergencies",draft:!1,editUrl:"https://github.com/iamsahu/yield-docs/tree/master/docs/developers/emergencies.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Giver",permalink:"/yield-docs/developers/contracts/utils/Giver"},next:{title:"Governance",permalink:"/yield-docs/developers/governance"}},d={},p=[{value:"Timelock",id:"timelock",level:2},{value:"Protocol Pause",id:"protocol-pause",level:2},{value:"Cloak (EmergencyBrake)",id:"cloak-emergencybrake",level:2},{value:"Oracle Sources",id:"oracle-sources",level:2},{value:"Oracles",id:"oracles",level:2},{value:"Factories",id:"factories",level:2},{value:"Joins",id:"joins",level:2},{value:"Cauldron",id:"cauldron",level:2},{value:"Ladle",id:"ladle",level:2},{value:"Tokens",id:"tokens",level:3},{value:"Integrations",id:"integrations",level:3},{value:"Modules",id:"modules",level:3},{value:"Witch",id:"witch",level:2},{value:"Wand",id:"wand",level:2},{value:"Pools",id:"pools",level:2},{value:"Strategies",id:"strategies",level:2}],u={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"emergencies"},"Emergencies"),(0,a.kt)("p",null,"In Yield v2 there are two types of emergency procedures to effect change in the smart contracts as a response to an emergency: Emergency Plans, and Emergency Proposals."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Emergency Plans")),(0,a.kt)("p",null,"Emergency plans are stored in the Cloak (EmergencyBrake) and allow removing the orchestration between contracts easily and safely. Executed emergency plans can be reverted easily by governance."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Emergency Proposals")),(0,a.kt)("p",null,"For those predictable emergencies that cannot be resolved with an Emergency Plan, Emergency Proposals can be proposed and approved in the Timelock. The operations team can execute them rather easily in an emergency, and governance proposals can be passed, approved and executed to revert them. While more flexible, this approach is more complex and error-prone."),(0,a.kt)("h2",{id:"timelock"},"Timelock"),(0,a.kt)("p",null,"The Timelock has complete control over the protocol, and is likely to be the sole holder of the ROOT role in all contracts."),(0,a.kt)("p",null,"A compromised Timelock is likely to be catastrophic. If possible, the procedure to deploy a new Timelock and decommission the compromised one should be followed."),(0,a.kt)("p",null,"To add a new Timelock, it needs to be given permissions on the smart contracts that will fall under its control. The permissions given any or all of the governance functions in each of the contracts, and possibly the ROOT as well. Giving permissions is done through a proposal in an existing Timelock with ROOT permissions over the smart contracts in scope."),(0,a.kt)("p",null,"To remove an existing Timelock, the operations dashboard needs to be used to find its permissions in each contract in the protocol, and then a proposal passed through a Timelock with ROOT permissions over the contracts in scope. Special care is needed in not remaining without ROOT access to any smart contract, unless specifically intending to do so."),(0,a.kt)("p",null,"If there are no accounts with ROOT access to a smart contract, permissions cannot be changed for that smart contract ever again. The EmergencyBrake doesn\u2019t count as having ROOT access in this context, as it can\u2019t give new access control permissions."),(0,a.kt)("h2",{id:"protocol-pause"},"Protocol Pause"),(0,a.kt)("p",null,"A complete pause of the protocol can be achieved by executing all Emergency Plans, preferably in this order:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"All Joins, to protect assets."),(0,a.kt)("li",{parentName:"ol"},"Ladle and Witch, to protect accounting."),(0,a.kt)("li",{parentName:"ol"},"All FYToken, to protect fyToken supply.")),(0,a.kt)("p",null,"This pause can be lifted easily by the governor through a special zero-delay Timelock."),(0,a.kt)("p",null,"If it is suspected that the Ladle is being abused to take assets out of user wallets, all token integrations should be removed from the Ladle using an Emergency Proposal. Note this includes assets, fyTokens, pools and strategies. This can only be restored through governance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addToken(token, false)\n")),(0,a.kt)("h2",{id:"cloak-emergencybrake"},"Cloak (EmergencyBrake)"),(0,a.kt)("p",null,"The Cloak can temporarily disable the orchestration between smart contracts in the protocol. To do so it holds the ROOT role to all smart contracts under its scope."),(0,a.kt)("p",null,"In the case of a compromised Cloak, a proposal must be passed through the Timelock to revoke the Cloak ROOT permissions to all contracts under its scope. This will render the compromised Cloak powerless and effectively terminated."),(0,a.kt)("h2",{id:"oracle-sources"},"Oracle Sources"),(0,a.kt)("p",null,"A malfunctioning oracle source can be disabled passing a proposal to set it to the zero address in the appropriate Oracle. Any further transactions requesting data for the related base and quote will revert."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"CompoundMultiOracle:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"oracle.setSource(baseId, quoteId, ZERO_ADDRESS)\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"ChainlinkMultiOracle:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"oracle.setSource(baseId, ZERO_ADDRESS, quoteId, ZERO_ADDRESS, ZERO_ADDRESS)\n")),(0,a.kt)("h2",{id:"oracles"},"Oracles"),(0,a.kt)("p",null,"A generalized Oracle malfunction, as opposed to a single source malfunction, can be addressed by removing the affected Oracle from the Cauldron or FYToken contracts."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"SpotOracle:")),(0,a.kt)("p",null,"A Timelock proposal is required to set the spot oracle to the zero address for ",(0,a.kt)("strong",{parentName:"p"},"all")," impacted base and ilk pairs. Any further transactions requiring collateralization checks will revert."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cauldron.setSpotOracle(baseId, ilkId, ZERO_ADDRESS, ratio)\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"LendingOracle:")),(0,a.kt)("p",null,"A Timelock proposal is required to set in the Cauldron the lending oracle to the zero address for all impacted assets, the same proposal should also set the chi oracle to the zero address for all impacted FYToken. Any further transactions involving collateralization checks, FYToken maturing or redemptions will revert."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cauldron.setLendingOracle(baseId, ZERO_ADDRESS)\nfyToken.point(bytes32('oracle'), ZERO_ADDRESS)\n")),(0,a.kt)("h2",{id:"factories"},"Factories"),(0,a.kt)("p",null,"A malfunctioning Factory (JoinFactory, FYTokenFactory, PoolFactory) is unlikely to become a time critical emergency, unless the Wand is compromised as well. Factories are called by the Wand to deploy and permission new assets, make them ilks and/or bases, and deploy and permission new series."),(0,a.kt)("p",null,"In the case of a compromised factory, the safest option is to execute the Wand Emergency plan. Any further transactions using the Wand will revert."),(0,a.kt)("h2",{id:"joins"},"Joins"),(0,a.kt)("p",null,"A malfunctioning Join can compromise protocol assets, and action must be taken immediately. In such an emergency, execute a Protocol Pause."),(0,a.kt)("h2",{id:"cauldron"},"Cauldron"),(0,a.kt)("p",null,"A malfunctioning Cauldron will be catastrophic, as it can\u2019t be replaced. In such an emergency, execute a Protocol Pause. With the protocol effectively paused, a plan can be made to extract the assets from the Joins and return them to users according to a shutdown plan."),(0,a.kt)("h2",{id:"ladle"},"Ladle"),(0,a.kt)("p",null,"A malfunctioning Ladle is a very serious issue, and action must be taken immediately. In such an emergency, execute the Ladle Emergency Plan. Any transactions involving collateral or debt will revert after this, but liquidations, redemptions, and transactions involving only YieldSpace pools, Ladle modules, Ladle integrations or Ladle token transfers can still take place."),(0,a.kt)("p",null,"If required to disable Ladle modules, integrations or token transfers, read below."),(0,a.kt)("h3",{id:"tokens"},"Tokens"),(0,a.kt)("p",null,"If necessary to remove a token integration, it must be done through an Emergency Proposal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addToken(token, false)\n")),(0,a.kt)("h3",{id:"integrations"},"Integrations"),(0,a.kt)("p",null,"If necessary to remove a contract integration, it must be done through an Emergency Proposal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addIntegration(integration, false)\n")),(0,a.kt)("h3",{id:"modules"},"Modules"),(0,a.kt)("p",null,"If necessary to remove a module integration, it must be done through an Emergency Proposal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addModule(module, false)\n")),(0,a.kt)("h2",{id:"witch"},"Witch"),(0,a.kt)("p",null,"A malfunctioning Witch can be a very serious issue, affecting all protocol solvency, accountancy, and user assets. In such an emergency, execute the Emergency Plan for the Witch, which will disconnect it from the Cauldron, and all the Emergency Plans disconnecting the Witch from a Join. There will be many of the latter."),(0,a.kt)("h2",{id:"wand"},"Wand"),(0,a.kt)("p",null,"The Wand is not user-facing, but a compromised Wand could be used to add compromised assets to the protocol, which in turn could be used for further attacks. In such an emergency, execute the Emergency Plan for the Wand, which will effectively disable it."),(0,a.kt)("h2",{id:"pools"},"Pools"),(0,a.kt)("p",null,"The Pools themselves are not controlled by governance, but in the case of a compromised Pool it can be removed from the Ladle using an Emergency Proposal to remove the related integrations. Note that the pools are usually deployed using the PoolFactory, in which case all Pools deployed by the same factory should be removed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addToken(pool, false)\nladle.addIntegration(pool, false)\n")),(0,a.kt)("h2",{id:"strategies"},"Strategies"),(0,a.kt)("p",null,"In a case of a Strategy malfunction, it can be removed from the Ladle. However, this will not be completely effective in protecting user assets, as the Strategy functions can be executed directly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ladle.addToken(strategy, false)\nladle.addIntegration(strategy, false)\n")))}m.isMDXComponent=!0}}]);